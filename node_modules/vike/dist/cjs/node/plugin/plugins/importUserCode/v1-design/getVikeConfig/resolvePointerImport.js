"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.clearFilesEnvMap = exports.resolvePointerImport = exports.resolvePointerImportOfConfig = void 0;
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const utils_js_1 = require("../../../../utils.js");
const transformFileImports_js_1 = require("./transformFileImports.js");
const path_1 = __importDefault(require("path"));
const getFilePath_js_1 = require("../../../../shared/getFilePath.js");
const filesEnvMap = new Map();
function resolvePointerImportOfConfig(configValue, importerFilePath, userRootDir, configEnv, configName) {
    if (typeof configValue !== 'string')
        return null;
    const pointerImportData = (0, transformFileImports_js_1.parsePointerImportData)(configValue);
    if (!pointerImportData)
        return null;
    const { importPath, exportName } = pointerImportData;
    const filePath = resolvePointerImport(pointerImportData, importerFilePath, userRootDir);
    const fileExportPathToShowToUser = exportName === 'default' || exportName === configName ? [] : [exportName];
    assertFileEnv(filePath.filePathAbsoluteFilesystem, importPath, configEnv, configName);
    return {
        ...filePath,
        fileExportName: exportName,
        fileExportPathToShowToUser
    };
}
exports.resolvePointerImportOfConfig = resolvePointerImportOfConfig;
function resolvePointerImport(pointerImportData, importerFilePath, userRootDir) {
    const { importPath } = pointerImportData;
    const filePathAbsoluteFilesystem = resolveImportPathWithNode(pointerImportData, importerFilePath);
    let filePath;
    // - importPath is one of the following. (See `transpileAndExecuteFile()`.)
    //   - A relative import path
    //   - A filesystem absolute path
    //   - An npm package import
    // - importPath cannot be a path alias (since esbuild resolves path aliases, see transpileAndExecuteFile.ts)
    (0, utils_js_1.assertPosixPath)(importPath);
    if (importPath.startsWith('.') || (0, utils_js_1.isPathFilesystemAbsolute)(importPath)) {
        if (importPath.startsWith('.')) {
            (0, utils_js_1.assert)(importPath.startsWith('./') || importPath.startsWith('../'));
        }
        assertImportPath(filePathAbsoluteFilesystem, pointerImportData, importerFilePath);
        const filePathAbsoluteUserRootDir = (0, getFilePath_js_1.getFilePathAbsoluteUserRootDir)({ filePathAbsoluteFilesystem, userRootDir });
        // This assert() is guarenteed, see assertUsage() in the onResolve() esbuild hook in transpileAndExecuteFile.ts
        (0, utils_js_1.assert)(filePathAbsoluteUserRootDir);
        // Imports are included in virtual files, thus the relative path of imports need to resolved.
        // ```
        // [vite] Internal server error: Failed to resolve import "./onPageTransitionHooks" from "virtual:vike:pageConfigValuesAll:client:/pages/index". Does the file exist?
        // ```
        filePath = (0, getFilePath_js_1.getFilePathResolved)({ filePathAbsoluteUserRootDir, userRootDir });
    }
    else {
        const importPathAbsolute = importPath;
        // importPath cannot be a path alias (since esbuild resolves path aliases, see transpileAndExecuteFile.ts)
        (0, utils_js_1.assertIsNpmPackageImport)(importPathAbsolute);
        if (filePathAbsoluteFilesystem) {
            filePath = (0, getFilePath_js_1.getFilePathResolved)({
                userRootDir,
                filePathAbsoluteFilesystem,
                importPathAbsolute
            });
        }
        else {
            filePath = (0, getFilePath_js_1.getFilePathUnresolved)({
                importPathAbsolute
            });
        }
    }
    return filePath;
}
exports.resolvePointerImport = resolvePointerImport;
function resolveImportPathWithNode(pointerImportData, importerFilePath) {
    const importerFilePathAbsolute = importerFilePath.filePathAbsoluteFilesystem;
    (0, utils_js_1.assertPosixPath)(importerFilePathAbsolute);
    const cwd = path_1.default.posix.dirname(importerFilePathAbsolute);
    // We can't use import.meta.resolve() as of Junary 2023 (and probably for a lot longer)
    // https://stackoverflow.com/questions/54977743/do-require-resolve-for-es-modules#comment137174954_62272600:~:text=But%20the%20argument%20parent%20(aka%20cwd)%20still%20requires%20a%20flag
    // filePathAbsoluteFilesystem is expected to be null when pointerImportData.importPath is a Vite path alias
    const filePathAbsoluteFilesystem = (0, utils_js_1.requireResolve)(pointerImportData.importPath, cwd);
    return filePathAbsoluteFilesystem;
}
function assertImportPath(filePathAbsoluteFilesystem, pointerImportData, importerFilePath) {
    const { importPath: importPath, importStringWasGenerated, importString } = pointerImportData;
    const { filePathToShowToUser } = importerFilePath;
    if (!filePathAbsoluteFilesystem) {
        const importPathString = picocolors_1.default.cyan(`'${importPath}'`);
        const errIntro = importStringWasGenerated
            ? `The import path ${importPathString} in ${filePathToShowToUser}`
            : `The import ${picocolors_1.default.cyan(importString)} defined in ${filePathToShowToUser}`;
        const errIntro2 = `${errIntro} couldn't be resolved: does ${importPathString}`;
        if (importPath.startsWith('.')) {
            (0, utils_js_1.assert)(importPath.startsWith('./') || importPath.startsWith('../'));
            (0, utils_js_1.assertUsage)(false, `${errIntro2} point to an existing file?`);
        }
        else {
            (0, utils_js_1.assertUsage)(false, `${errIntro2} exist?`);
        }
    }
}
function assertFileEnv(filePathAbsoluteFilesystem, importPath, configEnv, configName) {
    let key;
    if (filePathAbsoluteFilesystem) {
        key = filePathAbsoluteFilesystem;
    }
    else {
        (0, utils_js_1.assertIsNpmPackageImport)(importPath);
        key = importPath;
    }
    (0, utils_js_1.assertPosixPath)(key);
    if (!filesEnvMap.has(key)) {
        filesEnvMap.set(key, []);
    }
    const fileEnv = filesEnvMap.get(key);
    fileEnv.push({ configEnv, configName });
    const configDifferentEnv = fileEnv.filter((c) => !(0, utils_js_1.deepEqual)(c.configEnv, configEnv))[0];
    if (configDifferentEnv) {
        (0, utils_js_1.assertUsage)(false, [
            `${key} defines the value of configs living in different environments:`,
            ...[configDifferentEnv, { configName, configEnv }].map((c) => `  - config ${picocolors_1.default.cyan(c.configName)} which value lives in environment ${picocolors_1.default.cyan(JSON.stringify(c.configEnv))}`),
            'Defining config values in the same file is allowed only if they live in the same environment, see https://vike.dev/config#pointer-imports'
        ].join('\n'));
    }
}
function clearFilesEnvMap() {
    filesEnvMap.clear();
}
exports.clearFilesEnvMap = clearFilesEnvMap;
