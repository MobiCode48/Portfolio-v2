"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.crawlPlusFiles = void 0;
const utils_js_1 = require("../../../../utils.js");
const path_1 = __importDefault(require("path"));
const fast_glob_1 = __importDefault(require("fast-glob"));
const child_process_1 = require("child_process");
const util_1 = require("util");
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const transpileAndExecuteFile_js_1 = require("./transpileAndExecuteFile.js");
const execA = (0, util_1.promisify)(child_process_1.exec);
(0, utils_js_1.assertIsNotProductionRuntime)();
(0, utils_js_1.assertIsSingleModuleInstance)('crawlPlusFiles.ts');
let gitIsNotUsable = false;
async function crawlPlusFiles(userRootDir, outDirAbsoluteFilesystem, isDev, crawlWithGit) {
    (0, utils_js_1.assertPosixPath)(userRootDir);
    (0, utils_js_1.assertPosixPath)(outDirAbsoluteFilesystem);
    let outDirRelativeFromUserRootDir = path_1.default.posix.relative(userRootDir, outDirAbsoluteFilesystem);
    if (outDirRelativeFromUserRootDir.startsWith('../')) {
        // config.outDir is outside of config.root => it's going to be ignored anyways
        outDirRelativeFromUserRootDir = null;
    }
    (0, utils_js_1.assert)(outDirRelativeFromUserRootDir === null ||
        /* Not true if outDirRelativeFromUserRootDir starts with a hidden directory (i.e. a directory with a name that starts with `.`)
        !outDirRelativeFromUserRootDir.startsWith('.') &&
        */
        (!outDirRelativeFromUserRootDir.startsWith('./') &&
            //
            !outDirRelativeFromUserRootDir.startsWith('../')));
    const timeBefore = new Date().getTime();
    // Crawl
    let files = [];
    const res = crawlWithGit !== false && (await gitLsFiles(userRootDir, outDirRelativeFromUserRootDir));
    if (res &&
        // Fallback to fast-glob for users that dynamically generate plus files. (Assuming all (generetad) plus files to be skipped because users usually included them in `.gitignore`.)
        res.length > 0) {
        files = res;
    }
    else {
        files = await fastGlob(userRootDir, outDirRelativeFromUserRootDir);
    }
    // Filter build files
    files = files.filter((file) => !(0, transpileAndExecuteFile_js_1.isTemporaryBuildFile)(file));
    // Check performance
    {
        const timeAfter = new Date().getTime();
        const timeSpent = timeAfter - timeBefore;
        if (isDev) {
            // We only warn in dev, because while building it's expected to take a long time as crawling is competing for resources with other tasks.
            // Although, in dev, it's also competing for resources e.g. with Vite's `optimizeDeps`.
            (0, utils_js_1.assertWarning)(timeSpent < 3 * 1000, `Crawling your ${picocolors_1.default.cyan('+')} files took an unexpected long time (${(0, utils_js_1.humanizeTime)(timeSpent)}). If you repeatedly get this warning, then consider creating a new issue on Vike's GitHub.`, {
                onlyOnce: 'slow-page-files-search'
            });
        }
    }
    // Normalize
    const plusFiles = files.map((filePath) => {
        // Both `$ git-ls files` and fast-glob return posix paths
        (0, utils_js_1.assertPosixPath)(filePath);
        (0, utils_js_1.assert)(!filePath.startsWith(userRootDir));
        const filePathAbsoluteUserRootDir = path_1.default.posix.join('/', filePath);
        return { filePathAbsoluteUserRootDir };
    });
    return plusFiles;
}
exports.crawlPlusFiles = crawlPlusFiles;
// Same as fastGlob() but using `$ git ls-files`
async function gitLsFiles(userRootDir, outDirRelativeFromUserRootDir) {
    if (gitIsNotUsable)
        return null;
    // Preserve UTF-8 file paths.
    // https://github.com/vikejs/vike/issues/1658
    // https://stackoverflow.com/questions/22827239/how-to-make-git-properly-display-utf-8-encoded-pathnames-in-the-console-window/22828826#22828826
    // https://stackoverflow.com/questions/15884180/how-do-i-override-git-configuration-options-by-command-line-parameters/15884261#15884261
    const preserveUTF8 = '-c core.quotepath=off';
    const ignoreAsPatterns = getIgnoreAsPatterns(outDirRelativeFromUserRootDir);
    const ignoreAsFilterFn = getIgnoreAsFilterFn(outDirRelativeFromUserRootDir);
    const cmd = [
        'git',
        preserveUTF8,
        'ls-files',
        ...utils_js_1.scriptFileExtensionList.map((ext) => `"**/+*.${ext}"`),
        ...ignoreAsPatterns.map((pattern) => `--exclude="${pattern}"`),
        // --others lists untracked files only (but using .gitignore because --exclude-standard)
        // --cached adds the tracked files to the output
        '--others --cached --exclude-standard'
    ].join(' ');
    let files;
    let filesDeleted;
    try {
        ;
        [files, filesDeleted] = await Promise.all([
            // Main command
            runCmd1(cmd, userRootDir),
            // Get tracked by deleted files
            runCmd1('git ls-files --deleted', userRootDir)
        ]);
    }
    catch (err) {
        if (await isGitNotUsable(userRootDir)) {
            gitIsNotUsable = true;
            return null;
        }
        throw err;
    }
    files = files
        // We have to repeat the same exclusion logic here because the `git ls-files` option --exclude only applies to untracked files. (We use --exclude only to speed up the command.)
        .filter(ignoreAsFilterFn)
        .filter((file) => !filesDeleted.includes(file));
    return files;
}
// Same as gitLsFiles() but using fast-glob
async function fastGlob(userRootDir, outDirRelativeFromUserRootDir) {
    const files = await (0, fast_glob_1.default)(`**/+*.${utils_js_1.scriptFileExtensions}`, {
        ignore: getIgnoreAsPatterns(outDirRelativeFromUserRootDir),
        cwd: userRootDir,
        dot: false
    });
    return files;
}
// Same as getIgnoreFilter() but as glob pattern
function getIgnoreAsPatterns(outDirRelativeFromUserRootDir) {
    const ignoreAsPatterns = [
        '**/node_modules/**',
        // Allow:
        // ```
        // +Page.js
        // +Page.telefunc.js
        // ```
        '**/*.telefunc.*'
    ];
    if (outDirRelativeFromUserRootDir) {
        (0, utils_js_1.assert)(!outDirRelativeFromUserRootDir.startsWith('/'));
        ignoreAsPatterns.push(`${outDirRelativeFromUserRootDir}/**`);
    }
    return ignoreAsPatterns;
}
// Same as getIgnorePatterns() but for Array.filter()
function getIgnoreAsFilterFn(outDirRelativeFromUserRootDir) {
    (0, utils_js_1.assert)(outDirRelativeFromUserRootDir === null || !outDirRelativeFromUserRootDir.startsWith('/'));
    return (file) => !file.includes('node_modules/') &&
        !file.includes('.telefunc.') &&
        (outDirRelativeFromUserRootDir === null || !file.startsWith(`${outDirRelativeFromUserRootDir}/`));
}
// Whether Git is installed and whether we can use it
async function isGitNotUsable(userRootDir) {
    // Check Git version
    {
        const res = await runCmd2('git --version', userRootDir);
        if ('err' in res)
            return true;
        let { stdout, stderr } = res;
        (0, utils_js_1.assert)(stderr === '');
        const prefix = 'git version ';
        (0, utils_js_1.assert)(stdout.startsWith(prefix));
        const gitVersion = stdout.slice(prefix.length);
        //  - Works with Git 2.43.1 but also (most certainly) with earlier versions.
        //    - We didn't bother test which is the earliest verision that works.
        //  - Git 2.32.0 doesn't seem to work: https://github.com/vikejs/vike/discussions/1549
        //    - Maybe it's because of StackBlitz: looking at the release notes, Git 2.32.0 should be working.
        if (!(0, utils_js_1.isVersionOrAbove)(gitVersion, '2.43.1'))
            return true;
    }
    // Is userRootDir inside a Git repository?
    {
        const res = await runCmd2('git rev-parse --is-inside-work-tree', userRootDir);
        if ('err' in res)
            return true;
        let { stdout, stderr } = res;
        (0, utils_js_1.assert)(stderr === '');
        (0, utils_js_1.assert)(stdout === 'true');
        return false;
    }
}
async function runCmd1(cmd, cwd) {
    const { stdout } = await execA(cmd, { cwd });
    /* Not always true: https://github.com/vikejs/vike/issues/1440#issuecomment-1892831303
    assert(res.stderr === '')
    */
    return stdout.toString().split('\n').filter(Boolean);
}
async function runCmd2(cmd, cwd) {
    let res;
    try {
        res = await execA(cmd, { cwd });
    }
    catch (err) {
        return { err };
    }
    let { stdout, stderr } = res;
    stdout = stdout.toString().trim();
    stderr = stderr.toString().trim();
    return { stdout, stderr };
}
